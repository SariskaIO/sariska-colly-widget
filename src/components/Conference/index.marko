import SariskaMediaTransport from "sariska-media-transport";
import { MUTE_ALL_TOGGLE, VIDEO_TOGGLE, WIDGET_TOGGLE, CALL_END, MIC_TOGGLE, RECORDING_TOGGLE, FULL_SCREEN_TOGGLE } from "../../constants";
import { getDimensions } from  "../../utils";
import "./index.scss";

class  {

   onCreate(input) {
      const { connection } = input;
      this.state = {
         conference: null,
         recordingSession: null,
         presenterId: null,
         remoteTracks : [],
         zoomIn: false,
         isMouseDown: false,
         coordinateShift: {},
         recordingEnabled: false,
         localTracks: []
      }

      this.mouseMoveRef = this.mouseMove.bind(this);
      const conference = connection.initJitsiConference({ startAudioMuted: !input.audioEnabled, startVideoMuted: !input.videoEnabled });
      conference.on(SariskaMediaTransport.events.conference.TRACK_ADDED, removeTrackAdded.bind(this));
      conference.on(SariskaMediaTransport.events.conference.TRACK_REMOVED, remoteTrackRemoved.bind(this));
      conference.on(SariskaMediaTransport.events.conference.TRACK_MUTE_CHANGED, onTrackMuteChanged.bind(this));
      conference.on(SariskaMediaTransport.events.conference.CONFERENCE_JOINED, ()=>{
        conference.getParticipants().forEach(item=>{
            if (item._properties && item._properties.hasOwnProperty("recording")) {
                this.state.recordingEnabled = true;
            }
            if (item._properties.presenting === "start") {
              this.state.presenterId = participant._id;
            }
        });
      });

      conference.on(SariskaMediaTransport.events.conference.PARTICIPANT_PROPERTY_CHANGED, (participant, key, oldValue, newValue) =>{
          if (key === "presenting" && newValue === "start") {
              this.state.presenterId = participant._id;
              conference.selectParticipant(participant._id);
          }

          if (key === "presenting" && newValue === "stop") {
              this.state.presenterId = null;
              this.setStateDirty("remoteTracks");
          }
      });

      conference.join();
      this.state.conference = conference;
      input.conferenceInitialized(conference);

      const setupLocalStream = async ()=> {
         const tracks = await SariskaMediaTransport.createLocalTracks({devices:["audio", "video"], resolution: "180"});
         tracks.forEach(item=>conference.addTrack(item));
         this.state.localTracks = tracks;
         input.tracksInitialized(tracks);
         this.setStateDirty("localTracks");
      }

      setupLocalStream();

      function remoteTrackRemoved(track) {
         this.state.remoteTracks = this.state.remoteTracks.filter(item=>item.track.id!==track.track.id);
         this.setStateDirty("remoteTracks");
      }

      function removeTrackAdded(track) {
         if (!track  || track.isLocal()) {
             return;
         }
         
         console.log("remote track added", track);

         this.state.remoteTracks.push(track);
         this.setStateDirty("remoteTracks");
      }

      function onTrackMuteChanged() {
          this.setStateDirty("remoteTracks");
      }

      window.addEventListener("beforeunload", this.leaveConference.bind(this));
   }

   async videoControlAction(actionKey, value) {
       this.input.onMediaControlChange(actionKey, value);
       switch(actionKey) {
          case VIDEO_TOGGLE:
             this.state.localTracks.forEach(track=>{
                if ( track.getType() === "video" ) {
                   track.isMuted() ? track.unmute(): track.mute();
                }
            });
            break;
          case MUTE_ALL_TOGGLE:
             this.state.conference.getParticipants().forEach(participant=>{
                 this.state.conference.muteParticipant(participant.getJid(), value);
             });
             break;
          case MIC_TOGGLE:
             this.state.localTracks.forEach(track=>{
                if (track.getType()==="audio") {
                   track.isMuted() ? track.unmute(): track.mute();
                }
             });
             break;
          case FULL_SCREEN_TOGGLE:
             this.state.zoomIn = !this.state.zoomIn;
             break;
          default:
            console.log("hi")
       }
   }

   mouseUp() {
      setTimeout(()=>{ this.state.isMouseDown = false}, false);
      clearTimeout(this.timeout);
      this.skipMousemove = false;
      document.removeEventListener("mousemove", this.mouseMoveRef, true);
   }

   mouseMove(e) {
      const element = this.getEl("mediaWidget");
      const boudingRect  = element.getBoundingClientRect();
      element.style.bottom = this.state.coordinateShift.y - e.clientY + this.state.coordinateShift.bottom + 'px';
      element.style.left =  e.clientX - this.state.coordinateShift.left+ 'px';
   }

   mouseDown(e) {
      const element = this.getEl("mediaWidget");
      this.timeout = setTimeout(()=>{ this.state.isMouseDown = true }, 300);
      const boundingRect  = element.getBoundingClientRect();
      const bottom = e.clientY - boundingRect.bottom;
      const left = e.clientX - boundingRect.left;
      const dim = getDimensions();
      this.state.coordinateShift = { x: dim.x, y: dim.y, bottom, left};
      document.addEventListener("mousemove", this.mouseMoveRef, true);
   }

   closeSession(actionKey, value) {
      this.leaveConference();
      this.input.closeCurrentSession();
   }

   leaveConference(event) {
      if ( this.state.conference && this.state.conference.isJoined() ) {
         this.state.conference.leave().then(() => this.input.connection.disconnect(event));
      }
      this.state.localTracks.forEach(item => item.dispose())
   }

   onDestroy() {
     this.leaveConference();
   }

}

<div id="cb--media-container"  onMouseUp("mouseUp") onMouseDown("mouseDown") key="mediaWidget"  class=["cb__mediaContainer", "mdc-elevation--z6"]>
   <VideoControls 
        primaryColor = component.input.primaryColor
        primaryBackgroundColor = component.input.primaryBackgroundColor 
        recordingEnabled = state.recordingEnabled 
        isPublisher=component.input.isPublisher 
        closeSession = component.closeSession.bind(component)  
        videoControlAction = component.videoControlAction.bind(component) 
        widgetToggle=component.input.widgetToggle  
        videoEnabled=component.input.videoEnabled  
        muteAll=component.input.muteAll 
        videoWidget=component.input.videoWidget 
   />
   <div class=["cb__mediaContainer__widget"]>
         <LocalStream 
              primaryBackgroundColor = component.input.primaryBackgroundColor
              primaryColor = component.input.primaryColor
              videoEnabled=component.input.videoEnabled  
              videoWidget = component.input.videoWidget     
              audioEnabled=component.input.audioEnabled  
              videoControlAction = component.videoControlAction.bind(component) 
              localTracks = state.localTracks 
              conference = state.conference
          />
          <RemoteStream
              zoomIn = state.zoomIn
              primaryBackgroundColor = component.input.primaryBackgroundColor
              primaryColor = component.input.primaryColor
              presenterId = state.presenterId
              videoWidget = component.input.videoWidget 
              remoteTracks = state.remoteTracks  
              videoControlAction = component.videoControlAction.bind(component) 
              conference = state.conference 
          />

          <if(state.zoomIn)>
             <for|track, index| of=state.remoteTracks>
                  <if (track.getParticipantId() === state.presenterId && track.getType() === "video")>
                      <LargeVideo
                          key=track.track.id
                          isSharing = true 
                          user={} 
                          track=track
                      />
                  </if>
             </for>
         </if>
   </div>
</div>
