import SariskaMediaTransport from "sariska-media-transport";
import { MUTE_ALL_TOGGLE, VIDEO_TOGGLE, WIDGET_TOGGLE, CALL_END, MIC_TOGGLE, RECORDING_TOGGLE } from "../../constants";
import { getDimensions } from  "../../utils";
import "./index.scss";

class  {

   onCreate(input) {
      const { connection } = input;
      this.state = {
         conference: null,
         isMouseDown: false,
         coordinateShift: {},
         recordingSession: null,
         remoteTracks : [],
         recordingEnabled: false,
         localTracks: []
      }

      this.mouseMoveRef = this.mouseMove.bind(this);
      const conference = connection.initJitsiConference({ startAudioMuted: !input.audioEnabled, startVideoMuted: !input.videoEnabled });
      conference.on(SariskaMediaTransport.events.conference.TRACK_ADDED, removeTrackAdded.bind(this));
      conference.on(SariskaMediaTransport.events.conference.TRACK_REMOVED, remoteTrackRemoved.bind(this));
      conference.on(SariskaMediaTransport.events.conference.TRACK_MUTE_CHANGED, onTrackMuteChanged.bind(this));
      conference.on(SariskaMediaTransport.events.conference.CONFERENCE_JOINED, ()=>{
        conference.getParticipants().forEach(item=>{
            if (item._properties && item._properties.hasOwnProperty("recording")) {
                this.state.recordingEnabled = true;
            }
        });
      });
      conference.on(SariskaMediaTransport.events.conference.RECORDER_STATE_CHANGED, (data) => {
            if (data._status === "on" && data._mode === "file") {
                this.state.recordingEnabled = true;
                input.showToast("Recording Started");
            }

            if (data._status === "off" && data._mode === "file") {
                this.state.recordingEnabled = false;
                input.showToast("Recording Stopped");
            }
      });

      conference.join();
      this.state.conference = conference;

      const setupLocalStream = async ()=> {
         const tracks = await SariskaMediaTransport.createLocalTracks({devices:["audio", "video"], resolution: "180"});
         tracks.forEach(item=>conference.addTrack(item));
         this.state.localTracks = tracks;
         this.setStateDirty("localTracks");
      }

      setupLocalStream();

      function remoteTrackRemoved(track) {
         this.state.remoteTracks = this.state.remoteTracks.filter(item=>item.track.id!==track.track.id);
         this.setStateDirty("remoteTracks");
      }

      function removeTrackAdded(track) {
         if (!track  || track.isLocal()) {
             return;
         }
         this.state.remoteTracks.push(track);
         this.setStateDirty("remoteTracks");
      }

      function onTrackMuteChanged() {
          this.setStateDirty("remoteTracks");
      }

      window.addEventListener("beforeunload", this.leaveConference.bind(this));
   }

   mouseUp() {
      setTimeout(()=>{ this.state.isMouseDown = false}, false);
      clearTimeout(this.timeout);
      this.skipMousemove = false;
      document.removeEventListener("mousemove", this.mouseMoveRef, true);
   }

   mouseMove(e) {
      const element = this.getEl("mediaWidget");
      const boudingRect  = element.getBoundingClientRect();
      element.style.bottom = this.state.coordinateShift.y - e.clientY + this.state.coordinateShift.bottom + 'px';
      element.style.left =  e.clientX - this.state.coordinateShift.left+ 'px';
   }

   mouseDown(e) {
      const element = this.getEl("mediaWidget");
      this.timeout = setTimeout(()=>{ this.state.isMouseDown = true }, 300);
      const boundingRect  = element.getBoundingClientRect();
      const bottom = e.clientY - boundingRect.bottom;
      const left = e.clientX - boundingRect.left;
      const dim = getDimensions();
      this.state.coordinateShift = { x: dim.x, y: dim.y, bottom, left};
      document.addEventListener("mousemove", this.mouseMoveRef, true);
   }

   async videoControlAction(actionKey, value) {
       this.input.onMediaControlChange(actionKey, value);
       switch(actionKey) {
          case VIDEO_TOGGLE:
             this.state.localTracks.forEach(track=>{
                if ( track.getType() === "video" ) {
                   track.isMuted() ? track.unmute(): track.mute();
                }
            });
            break;
          case MUTE_ALL_TOGGLE:
             this.state.conference.getParticipants().forEach(participant=>{
                 this.state.conference.muteParticipant(participant.getJid(), value);
             });
             break;
          case RECORDING_TOGGLE:
              if (!this.state.recordingSession) {
                  const appData = {
                      file_recording_metadata : {
                         'share': true
                      }
                  };
                  const session = await this.state.conference.startRecording({
                      mode: SariskaMediaTransport.constants.recording.mode.FILE,
                      appData: JSON.stringify(appData)
                  });
                  this.state.recordingSession = session;
                  this.state.conference.setLocalParticipantProperty("recording");
              } else {
                  await this.state.conference.stopRecording(this.state.recordingSession._sessionID);
                  this.state.conference.removeLocalParticipantProperty("recording");
                  this.state.recordingSession = null;
              }
              break;
          case MIC_TOGGLE:
             this.state.localTracks.forEach(track=>{
                if (track.getType()==="audio") {
                   track.isMuted() ? track.unmute(): track.mute();
                }
             });
             break;
          default:
            console.log("hi")
       }
   }

   closeSession(actionKey, value) {
      this.leaveConference();
      this.input.closeCurrentSession();
   }

   leaveConference(event) {
      if ( this.state.conference && this.state.conference.isJoined() ) {
         this.state.conference.leave().then(() => this.input.connection.disconnect(event));
      }
      this.state.localTracks.forEach(item => item.dispose())
   }

   onDestroy() {
     this.leaveConference();
   }

}

<div id="cb--media-container" onMouseUp("mouseUp") onMouseDown("mouseDown") key="mediaWidget" class=["cb__mediaContainer", "mdc-elevation--z6"]>
   <VideoControls recordingEnabled = state.recordingEnabled isPublisher=component.input.isPublisher closeSession = component.closeSession.bind(component)  videoControlAction = component.videoControlAction.bind(component) widgetToggle=component.input.widgetToggle  videoEnabled=component.input.videoEnabled  muteAll=component.input.muteAll videoWidget=component.input.videoWidget />
   <div class=["cb__mediaContainer__widget"]>
        <div.cb__mediaContainer__local><LocalStream videoEnabled=component.input.videoEnabled  videoWidget = component.input.videoWidget audioEnabled=component.input.audioEnabled  videoControlAction = component.videoControlAction.bind(component) localTracks = state.localTracks conference = state.conference /></div>
        <div.cb__mediaContainer__remote><RemoteStream  videoWidget = component.input.videoWidget remoteTracks = state.remoteTracks  videoControlAction = component.videoControlAction.bind(component) conference = state.conference /></div>
   </div>
</div>
